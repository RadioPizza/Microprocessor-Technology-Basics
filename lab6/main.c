#include "main.h"

#define LED_PORT PG
#define LED_PIN  0

#define IS_TIMER_OVERFLOW() (TIM1_SR1 & (1 << 0))

#define PWM_PERIOD 200              // Период программного ШИМ
volatile uint8_t pwm_counter = 0;   // Счётчик тактов ШИМ (0 .. PWM_PERIOD-1)
volatile uint8_t pwm_value   = 0;   // Текущее значение скважности (0 .. PWM_PERIOD)
volatile int8_t  direction   = 1;   // Направление изменения: +1 - увеличение, -1 - уменьшение

/**
 * @brief Задержка в микросекундах с использованием таймера TIM1.
 *
 * @param us Количество микросекунд для задержки.
 * @note Эта функция имеет оверхед около 30 мкс.
 */
void delay_us(uint16_t us)
{
    --us;                  // Уменьшаем значение на 1 для корректной работы
    TIM1_CR1 |= 0x04;      // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00;     // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x01;     // Устанавливаем младший байт делителя
    TIM1_EGR |= 0x01;      // Генерация обновления
    TIM1_ARRH = us >> 8;   // Загружаем старший байт регистра автоперезагрузки
    TIM1_ARRL = us & 0xFF; // Загружаем младший байт регистра автоперезагрузки
    TIM1_CR1 &= ~0x04;     // Выключаем ARPE
    TIM1_CR1 |= 0x09;      // Включаем таймер в режиме one-pulse mode
    while (!IS_TIMER_OVERFLOW())
        // Ждем переполнения таймера
        ;
    TIM1_SR1 = 0x00;    // Сбрасываем флаг обновления
}

/**
 * @brief Задержка в миллисекнудах с использованием таймера TIM1.
 *
 * @param ms Количество миллисекунд для задержки.
 */
void delay_ms(uint16_t ms)
{
    uint16_t i;
    for (i = 0; i < ms; i++)
    {
        delay_us(970);  // 1000 мкс = 1 мс; учитываем оверхед 30 мкс
    }
}

/**
 * @brief Обработчик прерывания таймера TIM1 (переполнение).
 *
 * @note Эта функция вызывается при переполнении таймера TIM1.
 *       Инвертирует нулевой бит порта G и сбрасывает флаг переполнения.
 */
@far @interrupt void TIM1_IRQHandler(void)
{
    pwm_counter++;  // Переход к следующему такту ШИМ
    if (pwm_counter >= PWM_PERIOD)
    {
        pwm_counter = 0;
        
        // Обновление значения скважности
        pwm_value += direction;
        if ((pwm_value == PWM_PERIOD) || (pwm_value == 0))
        {
            direction = -direction;
        }
    }
    
    // Генерация программного ШИМ на PG0
    if (pwm_counter < pwm_value)
    {
        PG_ODR = 0x01;
    }
    else
    {
        PG_ODR = 0x00;
    }
}

/**
 * @brief Инициализация таймера TIM1 для генерации прерываний с заданной частотой.
 *
 * @param period_us Период переполнения таймера в микросекундах.
 */
void tim1_init(uint32_t period_us)
{
    // Для 2 МГц тактирования, делитель 1, такт = 0,5 мкс
    // Для period_us микросекунд, нужно period_us / 0.5 = period_us * 2 такта.
    // Поэтому, устанавливаем ARR = period_us * 2 - 1.
    uint16_t arr_value = period_us * 2 - 1;

    TIM1_CR1 &= ~0x01;  // Выключаем таймер, чтобы безопасно настроить его
    TIM1_CR1 |= 0x04;   // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00;  // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x00;  // Устанавливаем младший байт делителя (делитель 1)
    TIM1_ARRH = arr_value >> 8;
    TIM1_ARRL = arr_value & 0xFF;
    TIM1_EGR |= 0x01;       // Генерация обновления, чтобы применить новые значения ARR и PSC
    TIM1_IER |= (1 << 0);   // Разрешаем прерывание по переполнению (UIE)
    TIM1_CR1 &= ~0x04;      // Выключаем ARPE после настройки
    TIM1_CR1 |= 0x01;       // Включаем таймер
}

void main(void)
{
    // Настройка порта G: настраиваем вывод PG0 для работы со светодиодом.
    PG_DDR |= (1 << 0);  // PG0 - выход
    PG_CR1 |= (1 << 0);  // PG0 - двухтактный режим (push-pull)
    PG_CR2 |= (1 << 0);  // PG0 - максимальная скорость (10 МГц)

    // Инициализируем таймер TIM1 для генерации прерываний каждые 5 мс.
    tim1_init(5000);

    // Разрешаем глобальные прерывания (Run Interrupt Mode).
    _asm("rim");
}