# пункты 5-6

```C
// Подключение заголовочных файлов для работы с типами и регистрами
#include <stdint.h>
#include <iostm8s207.h>

// Определение константы для всех пинов (все биты выставлены в 1)
#define ALL_PINS 0xFF

// Определение битовой маски для линии E ЖК дисплея (бит 7)
#define LCD_E (1 << 7)

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void) 
{
    PF_ODR |= LCD_E;  // Устанавливаем линию E в высокий уровень
    delay(1);         // Задержка для обеспечения необходимой длительности импульса
    PF_ODR &= ~LCD_E; // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Основная функция программы
void main()
{
    // Настройка порта F: Все пины на выход, режим push-pull, низкая скорость переключения
    PF_DDR = ALL_PINS; // Настройка направления – все пины как выходы
    PF_CR1 = ALL_PINS; // Настройка внутреннего резистора (при выходе это режим push-pull)
    PF_CR2 = ALL_PINS; // Настройка скорости переключения – все пины с низкой скоростью

    // Настройка порта B: Аналогично настройка всех пинов как выходы в режиме push-pull
    PB_DDR = ALL_PINS;
    PB_CR1 = ALL_PINS;
    PB_CR2 = ALL_PINS;

    // Бесконечный цикл, в котором вызывается функция строба ЖК дисплея
    while (1)
    {
        LCD_strobe(); // Генерация строба
    }
}

```

# пункт 8

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Включить дисплей
#define TURN_OFF_COMMAND 0x3E // Выключить дисплей

// Пины ЖК дисплея
// Port B
#define LCD_D0 (1 << 0)
#define LCD_D1 (1 << 1)
#define LCD_D2 (1 << 2)
#define LCD_D3 (1 << 3)
#define LCD_D4 (1 << 4)
#define LCD_D5 (1 << 5)
#define LCD_D6 (1 << 6)
#define LCD_D7 (1 << 7)
// Port F
#define LCD_E1 (1 << 0)
#define LCD_E2 (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW (1 << 5)
#define LCD_A0 (1 << 6)
#define LCD_E (1 << 7)

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    PF_ODR |= LCD_E;  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    PF_ODR &= ~LCD_E; // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    PF_ODR &= ~LCD_RES; // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    PF_ODR |= LCD_RES;  // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    PF_ODR &= ~LCD_E;  // Строб E в низкий уровень
    PF_ODR &= ~LCD_A0; // Сигнал A0 (Data/Command) в низкий уровень
    PF_ODR &= ~LCD_RW; // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    PF_ODR |= (LCD_E1 | LCD_E2); // Устанавливаем E1 и E2 в высокий уровень

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();
}

```

# пункт 9

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Команда вкл. дисплея
#define TURN_OFF_COMMAND 0x3E // Команда выкл. дисплея

// Макросы для переключения режимов
#define LCD_DATA_MODE()   (PF_ODR |= LCD_A0)  // Переключение в режим данных (A0 = 1)
#define LCD_CMD_MODE()    (PF_ODR &= ~LCD_A0) // Переключение в режим команд (A0 = 0)

// Макросы для управления стробами E1 и E2
#define LCD_ENABLE_E1()   (PF_ODR |= LCD_E1)  // Включить E1
#define LCD_DISABLE_E1()  (PF_ODR &= ~LCD_E1) // Отключить E1
#define LCD_ENABLE_E2()   (PF_ODR |= LCD_E2)  // Включить E2
#define LCD_DISABLE_E2()  (PF_ODR &= ~LCD_E2) // Отключить E2

// Пины ЖК дисплея
// Port B
#define LCD_D0  (1 << 0)
#define LCD_D1  (1 << 1)
#define LCD_D2  (1 << 2)
#define LCD_D3  (1 << 3)
#define LCD_D4  (1 << 4)
#define LCD_D5  (1 << 5)
#define LCD_D6  (1 << 6)
#define LCD_D7  (1 << 7)
// Port F
#define LCD_E1  (1 << 0)
#define LCD_E2  (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW  (1 << 5)
#define LCD_A0  (1 << 6)
#define LCD_E   (1 << 7)

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    PF_ODR |= LCD_E;  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    PF_ODR &= ~LCD_E; // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    PF_ODR &= ~LCD_RES; // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    PF_ODR |= LCD_RES;  // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    PF_ODR &= ~LCD_E;  // Строб E в низкий уровень
    LCD_CMD_MODE();
    PF_ODR &= ~LCD_RW; // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    LCD_ENABLE_E1();
    LCD_ENABLE_E2();

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Функция для отрисовки буквы "M" на дисплее
void LCD_drawLetterM(void)
{
    // Включение первого контроллера дисплея (E1) и отключение второго (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    PB_ODR = 0b10111111;  // Команда выбора страницы (Page 0)
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    PB_ODR = 0b01000111;  // Команда выбора столбца (Column 0)
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "M" по столбцам слева направо
    PB_ODR = 0b01111111;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b00000100;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b01111111;
    LCD_strobe();
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();

    // Отрисовка буквы "M"
    LCD_drawLetterM();
}

```

# пункт 11

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Пины ЖК дисплея
// Port B
#define LCD_D0  (1 << 0)
#define LCD_D1  (1 << 1)
#define LCD_D2  (1 << 2)
#define LCD_D3  (1 << 3)
#define LCD_D4  (1 << 4)
#define LCD_D5  (1 << 5)
#define LCD_D6  (1 << 6)
#define LCD_D7  (1 << 7)
// Port F
#define LCD_E1  (1 << 0)
#define LCD_E2  (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW  (1 << 5)
#define LCD_A0  (1 << 6)
#define LCD_E   (1 << 7)

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Команда вкл. дисплея
#define TURN_OFF_COMMAND 0x3E // Команда выкл. дисплея

// Макросы для управления сигналавами
#define LCD_ENABLE_E()    (PF_ODR |= LCD_E)     // Включить E
#define LCD_DISABLE_E()   (PF_ODR &= ~LCD_E)    // Отключить E
#define LCD_ENABLE_E1()   (PF_ODR |= LCD_E1)    // Включить E1
#define LCD_DISABLE_E1()  (PF_ODR &= ~LCD_E1)   // Отключить E1
#define LCD_ENABLE_E2()   (PF_ODR |= LCD_E2)    // Включить E2
#define LCD_DISABLE_E2()  (PF_ODR &= ~LCD_E2)   // Отключить E2
#define LCD_RESET_ON()    (PF_ODR &= ~LCD_RES)  // Включить сброс (RESET = 0)
#define LCD_RESET_OFF()   (PF_ODR |= LCD_RES)   // Отключить сброс (RESET = 1)

// Макросы для переключения режимов
#define LCD_DATA_MODE()   (PF_ODR |= LCD_A0)  // Переключение в режим данных (A0 = 1)
#define LCD_CMD_MODE()    (PF_ODR &= ~LCD_A0) // Переключение в режим команд (A0 = 0)
#define LCD_READ_MODE()   (PF_ODR |= LCD_RW)  // Переключение в режим чтения (RW = 1)
#define LCD_WRITE_MODE()  (PF_ODR &= ~LCD_RW) // Переключение в режим записи (RW = 0)

// Макросы для выбора страницы и столбца
#define LCD_SET_PAGE(page) (PB_ODR = (0b10111000 | ((page) & 0b00000111))) // Выбор страницы
#define LCD_SET_COLUMN(column) (PB_ODR = (0b01000000 | ((column) & 0b00111111))) // Выбор столбца

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    LCD_ENABLE_E();  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    LCD_DISABLE_E(); // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    LCD_RESET_ON();     // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    LCD_RESET_OFF();    // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    LCD_DISABLE_E();   // Строб E в низкий уровень
    LCD_CMD_MODE();
    LCD_WRITE_MODE();  // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    LCD_ENABLE_E1();
    LCD_ENABLE_E2();

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Функция для отрисовки буквы "M" на дисплее
void LCD_drawLetterM(void)
{
    // Включение первого контроллера дисплея (E1) и отключение второго (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "M" по столбцам слева направо
    PB_ODR = 0b01111111;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b00000100;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b01111111;
    LCD_strobe();
}

// Функция для отрисовки прямоугольника 6x20 на дисплее
void LCD_drawRectangle(void)
{
    uint8_t col;
    // Включение кристалла 2 (E2) и отключение кристалла 1 (E1)
    LCD_ENABLE_E2();
    LCD_DISABLE_E1();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка прямоугольника по столбцам
    PB_ODR = 0b01111110; // Левая сторона прямоугольника
    LCD_strobe();

    // Внутренние столбцы (18 раз)
    for (col = 2; col < 20; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    PB_ODR = 0b01111110; // Правая сторона прямоугольника
    LCD_strobe();
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();

    // Отрисовка буквы "M"
    LCD_drawLetterM();

    // Отрисовка прямоугольника
    LCD_drawRectangle();
}

```

# пункт 13

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Пины ЖК дисплея
// Port B
#define LCD_D0  (1 << 0)
#define LCD_D1  (1 << 1)
#define LCD_D2  (1 << 2)
#define LCD_D3  (1 << 3)
#define LCD_D4  (1 << 4)
#define LCD_D5  (1 << 5)
#define LCD_D6  (1 << 6)
#define LCD_D7  (1 << 7)
// Port F
#define LCD_E1  (1 << 0)
#define LCD_E2  (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW  (1 << 5)
#define LCD_A0  (1 << 6)
#define LCD_E   (1 << 7)

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Команда вкл. дисплея
#define TURN_OFF_COMMAND 0x3E // Команда выкл. дисплея

// Макросы для управления сигналавами
#define LCD_ENABLE_E()    (PF_ODR |= LCD_E)     // Включить E
#define LCD_DISABLE_E()   (PF_ODR &= ~LCD_E)    // Отключить E
#define LCD_ENABLE_E1()   (PF_ODR |= LCD_E1)    // Включить E1
#define LCD_DISABLE_E1()  (PF_ODR &= ~LCD_E1)   // Отключить E1
#define LCD_ENABLE_E2()   (PF_ODR |= LCD_E2)    // Включить E2
#define LCD_DISABLE_E2()  (PF_ODR &= ~LCD_E2)   // Отключить E2
#define LCD_RESET_ON()    (PF_ODR &= ~LCD_RES)  // Включить сброс (RESET = 0)
#define LCD_RESET_OFF()   (PF_ODR |= LCD_RES)   // Отключить сброс (RESET = 1)

// Макросы для переключения режимов
#define LCD_DATA_MODE()   (PF_ODR |= LCD_A0)  // Переключение в режим данных (A0 = 1)
#define LCD_CMD_MODE()    (PF_ODR &= ~LCD_A0) // Переключение в режим команд (A0 = 0)
#define LCD_READ_MODE()   (PF_ODR |= LCD_RW)  // Переключение в режим чтения (RW = 1)
#define LCD_WRITE_MODE()  (PF_ODR &= ~LCD_RW) // Переключение в режим записи (RW = 0)

// Макросы для выбора страницы и столбца
#define LCD_SET_PAGE(page) (PB_ODR = (0b10111000 | ((page) & 0b00000111))) // Выбор страницы
#define LCD_SET_COLUMN(column) (PB_ODR = (0b01000000 | ((column) & 0b00111111))) // Выбор столбца

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    LCD_ENABLE_E();  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    LCD_DISABLE_E(); // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    LCD_RESET_ON();     // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    LCD_RESET_OFF();    // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    LCD_DISABLE_E();   // Строб E в низкий уровень
    LCD_CMD_MODE();
    LCD_WRITE_MODE();  // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    LCD_ENABLE_E1();
    LCD_ENABLE_E2();

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Функция для отрисовки буквы "M" на дисплее
void LCD_drawLetterM(void)
{
    // Включение первого контроллера дисплея (E1) и отключение второго (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "M" по столбцам слева направо
    PB_ODR = 0b01111111;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b00000100;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b01111111;
    LCD_strobe();
}

// Функция для отрисовки прямоугольника 6x55 на дисплее
void LCD_drawRectangle(void)
{
    uint8_t col;
    // Включение кристалла 2 (E2) и отключение кристалла 1 (E1)
    LCD_ENABLE_E2();
    LCD_DISABLE_E1();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка прямоугольника по столбцам
    PB_ODR = 0b01111110; // Левая сторона прямоугольника
    LCD_strobe();

    // Внутренние столбцы (53 раза)
    for (col = 2; col < 55; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    PB_ODR = 0b01111110; // Правая сторона прямоугольника
    LCD_strobe();
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();

    // Отрисовка буквы "M"
    LCD_drawLetterM();

    // Отрисовка прямоугольника
    LCD_drawRectangle();
}

```

# пункт 15

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Пины ЖК дисплея
// Port B
#define LCD_D0  (1 << 0)
#define LCD_D1  (1 << 1)
#define LCD_D2  (1 << 2)
#define LCD_D3  (1 << 3)
#define LCD_D4  (1 << 4)
#define LCD_D5  (1 << 5)
#define LCD_D6  (1 << 6)
#define LCD_D7  (1 << 7)
// Port F
#define LCD_E1  (1 << 0)
#define LCD_E2  (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW  (1 << 5)
#define LCD_A0  (1 << 6)
#define LCD_E   (1 << 7)

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Команда вкл. дисплея
#define TURN_OFF_COMMAND 0x3E // Команда выкл. дисплея

// Макросы для управления сигналавами
#define LCD_ENABLE_E()    (PF_ODR |= LCD_E)     // Включить E
#define LCD_DISABLE_E()   (PF_ODR &= ~LCD_E)    // Отключить E
#define LCD_ENABLE_E1()   (PF_ODR |= LCD_E1)    // Включить E1
#define LCD_DISABLE_E1()  (PF_ODR &= ~LCD_E1)   // Отключить E1
#define LCD_ENABLE_E2()   (PF_ODR |= LCD_E2)    // Включить E2
#define LCD_DISABLE_E2()  (PF_ODR &= ~LCD_E2)   // Отключить E2
#define LCD_RESET_ON()    (PF_ODR &= ~LCD_RES)  // Включить сброс (RESET = 0)
#define LCD_RESET_OFF()   (PF_ODR |= LCD_RES)   // Отключить сброс (RESET = 1)

// Макросы для переключения режимов
#define LCD_DATA_MODE()   (PF_ODR |= LCD_A0)  // Переключение в режим данных (A0 = 1)
#define LCD_CMD_MODE()    (PF_ODR &= ~LCD_A0) // Переключение в режим команд (A0 = 0)
#define LCD_READ_MODE()   (PF_ODR |= LCD_RW)  // Переключение в режим чтения (RW = 1)
#define LCD_WRITE_MODE()  (PF_ODR &= ~LCD_RW) // Переключение в режим записи (RW = 0)

// Макросы для выбора страницы и столбца
#define LCD_SET_PAGE(page) (PB_ODR = (0b10111000 | ((page) & 0b00000111))) // Выбор страницы
#define LCD_SET_COLUMN(column) (PB_ODR = (0b01000000 | ((column) & 0b00111111))) // Выбор столбца

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    LCD_ENABLE_E();  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    LCD_DISABLE_E(); // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    LCD_RESET_ON();     // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    LCD_RESET_OFF();    // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    LCD_DISABLE_E();   // Строб E в низкий уровень
    LCD_CMD_MODE();
    LCD_WRITE_MODE();  // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    LCD_ENABLE_E1();
    LCD_ENABLE_E2();

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Функция для отрисовки буквы "M" на дисплее
void LCD_drawLetterM(void)
{
    // Включение первого контроллера дисплея (E1) и отключение второго (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "M" по столбцам слева направо
    PB_ODR = 0b01111111;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b00000100;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b01111111;
    LCD_strobe();
}

// Функция для отрисовки прямоугольника 6x75 на дисплее
void LCD_drawRectangle(void)
{
    uint8_t col;

    // Первая часть: кристалл 1 (64 столбца)
    LCD_ENABLE_E1();  // Включить кристалл 1
    LCD_DISABLE_E2(); // Отключить кристалл 2

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка левой стороны прямоугольника
    PB_ODR = 0b01111110; // Левая сторона прямоугольника
    LCD_strobe();

    // Внутренние столбцы (63 раза, до конца кристалла)
    for (col = 1; col < 64; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    // Вторая часть: кристалл 2 (оставшиеся 11 столбцов)
    LCD_ENABLE_E2();  // Включить кристалл 2
    LCD_DISABLE_E1(); // Отключить кристалл 1

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка оставшихся 10 внутренних столбцов
    for (col = 64; col < 74; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    // Отрисовка правой стороны прямоугольника (75-й столбец)
    PB_ODR = 0b01111110; // Правая сторона прямоугольника
    LCD_strobe();
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();

    // Отрисовка прямоугольника
    LCD_drawRectangle();
}

```

# пункт 18

```C
#include <stdint.h>     // Для использования стандартных типов
#include <iostm8s207.h> // Для удобного обращения к регистрам переферии

// Пины ЖК дисплея
// Port B
#define LCD_D0  (1 << 0)
#define LCD_D1  (1 << 1)
#define LCD_D2  (1 << 2)
#define LCD_D3  (1 << 3)
#define LCD_D4  (1 << 4)
#define LCD_D5  (1 << 5)
#define LCD_D6  (1 << 6)
#define LCD_D7  (1 << 7)
// Port F
#define LCD_E1  (1 << 0)
#define LCD_E2  (1 << 3)
#define LCD_RES (1 << 4)
#define LCD_RW  (1 << 5)
#define LCD_A0  (1 << 6)
#define LCD_E   (1 << 7)

// Макросы для удобства
#define ALL_PINS 0xFF         // "1" для всех пинов порта
#define TURN_ON_COMMAND 0x3F  // Команда вкл. дисплея
#define TURN_OFF_COMMAND 0x3E // Команда выкл. дисплея

// Макросы для управления сигналавами
#define LCD_ENABLE_E()    (PF_ODR |= LCD_E)     // Включить E
#define LCD_DISABLE_E()   (PF_ODR &= ~LCD_E)    // Отключить E
#define LCD_ENABLE_E1()   (PF_ODR |= LCD_E1)    // Включить E1
#define LCD_DISABLE_E1()  (PF_ODR &= ~LCD_E1)   // Отключить E1
#define LCD_ENABLE_E2()   (PF_ODR |= LCD_E2)    // Включить E2
#define LCD_DISABLE_E2()  (PF_ODR &= ~LCD_E2)   // Отключить E2
#define LCD_RESET_ON()    (PF_ODR &= ~LCD_RES)  // Включить сброс (RESET = 0)
#define LCD_RESET_OFF()   (PF_ODR |= LCD_RES)   // Отключить сброс (RESET = 1)

// Макросы для переключения режимов
#define LCD_DATA_MODE()   (PF_ODR |= LCD_A0)  // Переключение в режим данных (A0 = 1)
#define LCD_CMD_MODE()    (PF_ODR &= ~LCD_A0) // Переключение в режим команд (A0 = 0)
#define LCD_READ_MODE()   (PF_ODR |= LCD_RW)  // Переключение в режим чтения (RW = 1)
#define LCD_WRITE_MODE()  (PF_ODR &= ~LCD_RW) // Переключение в режим записи (RW = 0)

// Макросы для выбора страницы и столбца
#define LCD_SET_PAGE(page) (PB_ODR = (0b10111000 | ((page) & 0b00000111))) // Выбор страницы
#define LCD_SET_COLUMN(column) (PB_ODR = (0b01000000 | ((column) & 0b00111111))) // Выбор столбца

// Функция задержки, реализующая задержку в миллисекундах.
// Использует вложенный цикл для создания временной паузы.
// Калибровка произведена для частоты 16 МГц, погрешность менее 5%
void delay(uint32_t ms)
{
    // Перебор каждой миллисекунды
    while (ms--)
    {
        // Переменная для внутреннего счета
        volatile uint16_t i;
        // Цикл для создания задержки на одну миллисекунду
        for (i = 0; i < 127; ++i) // Откалибровано c помощью осциллографа для STM8S207 16 MHz
        {
            _asm("nop"); // Ассемблерная команда "без операции" для создания задержки
        }
    }
}

// Функция строба для ЖК дисплея. Производит импульс на линии E для фиксации данных.
void LCD_strobe(void)
{
    LCD_ENABLE_E();  // Устанавливаем линию E в высокий уровень
    delay(23);        // Необходимая задержка установлена экспериментально
    LCD_DISABLE_E(); // Сбрасываем линию E в низкий уровень, завершая импульс
}

// Функция инициализации ЖК дисплея
void LCD_init(void)
{
    // Сброс дисплея
    LCD_RESET_ON();     // Устанавливаем сигнал RESET в низкий уровень
    delay(5);           // Задержка для обеспечения корректного прохождения сигнала сброса
    LCD_RESET_OFF();    // Устанавливаем сигнал RESET обратно в высокий уровень
    delay(20);          // Дополнительная задержка после сброса
    
    // Инициализация управляющих сигналов
    LCD_DISABLE_E();   // Строб E в низкий уровень
    LCD_CMD_MODE();
    LCD_WRITE_MODE();  // Сигнал RW (Read/Write) в низкий уровень (режим записи)

    // Включение обоих кристаллов (E1 и E2)
    LCD_ENABLE_E1();
    LCD_ENABLE_E2();

    // Отправка команды включения дисплея
    PB_ODR = TURN_ON_COMMAND; // Устанавливаем команду на шину данных
    LCD_strobe();             // Фиксируем команду на дисплее
}

// Функция для отрисовки буквы "M" на дисплее
void LCD_drawLetterM(void)
{
    // Включение первого контроллера дисплея (E1) и отключение второго (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "M" по столбцам слева направо
    PB_ODR = 0b01111111;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b00000100;
    LCD_strobe();
    PB_ODR = 0b00000010;
    LCD_strobe();
    PB_ODR = 0b01111111;
    LCD_strobe();
}

// Функция для отрисовки прямоугольника 6x75 на дисплее
void LCD_drawRectangle(void)
{
    uint8_t col;

    // Первая часть: кристалл 1 (64 столбца)
    LCD_ENABLE_E1();  // Включить кристалл 1
    LCD_DISABLE_E2(); // Отключить кристалл 2

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка левой стороны прямоугольника
    PB_ODR = 0b01111110; // Левая сторона прямоугольника
    LCD_strobe();

    // Внутренние столбцы (63 раза, до конца кристалла)
    for (col = 1; col < 64; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    // Вторая часть: кристалл 2 (оставшиеся 11 столбцов)
    LCD_ENABLE_E2();  // Включить кристалл 2
    LCD_DISABLE_E1(); // Отключить кристалл 1

    // Установка страницы (Page 0)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(0);      // Выбор страницы 0
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка оставшихся 10 внутренних столбцов
    for (col = 64; col < 74; col++) {
        PB_ODR = 0b01000010; // Внутренний столбец (верх и низ)
        LCD_strobe();
    }

    // Отрисовка правой стороны прямоугольника (75-й столбец)
    PB_ODR = 0b01111110; // Правая сторона прямоугольника
    LCD_strobe();
}

// Функция для отрисовки буквы "А" на дисплее
void LCD_drawLetterA(void)
{
    // Включение кристалла 1 (E1) и отключение кристалла 2 (E2)
    LCD_ENABLE_E1();
    LCD_DISABLE_E2();

    // Установка страницы (Page 1)
    LCD_CMD_MODE();       // Переключение в режим команд
    LCD_SET_PAGE(1);      // Выбор страницы 1
    LCD_strobe();         // Фиксируем команду

    // Установка начального столбца (Column 0)
    LCD_SET_COLUMN(0);    // Выбор столбца 0
    LCD_strobe();         // Фиксируем команду

    // Переключение в режим данных (A0 = 1)
    LCD_DATA_MODE();

    // Отрисовка буквы "А" по столбцам
    PB_ODR = 0b01111110; // Первый столбец
    LCD_strobe();
    PB_ODR = 0b00010001; // Второй столбец
    LCD_strobe();
    PB_ODR = 0b00010001; // Третий столбец
    LCD_strobe();
    PB_ODR = 0b00010001; // Четвёртый столбец
    LCD_strobe();
    PB_ODR = 0b01111110; // Пятый столбец
    LCD_strobe();
}

// Главная функция программы (точка входа)
void main()
{
    // Настройка портов PF и PB как выходных для управления дисплеем
    PF_DDR = ALL_PINS; // Направление порта F на вывод
    PF_CR1 = ALL_PINS; // Режим push-pull для порта F
    PF_CR2 = ALL_PINS; // Высокая скорость для порта F

    PB_DDR = ALL_PINS; // Направление порта B на вывод
    PB_CR1 = ALL_PINS; // Режим push-pull для порта B
    PB_CR2 = ALL_PINS; // Высокая скорость для порта B

    // Инициализация ЖК дисплея
    LCD_init();

    // Отрисовка буквы "А"
    LCD_drawLetterA();
}

```

# пункт 21

```C

```

# пункт 23

```C

```

# пункт 26

```C

```

