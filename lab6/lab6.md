# Пункт 2

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x80) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x80) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

# Пункт 3

## Характеристики полученного сигнала

Частота реального сигнала - 2 кГц, длительность импульса 60-65 мкс.

## Расчёт теоретических значений

Таймер настроен на частоту 2 МГц (предварительный делитель 1). Регистр автоперезагрузки (ARR) настроен на 1000 (0x03E8).

$$T = \frac{1}{f} = \frac{1}{2 \cdot 10^6 \text{ Гц}} = 0.5 \text{ мкс}$$

Условие внутри бесконечного цикла задаёт 128 тактов для логической "1" и оставшиеся (1000 - 128) = 872 такта для логической "0".
   
- Длительность "1" = 128 * 0.5 мкс = 64 мкс.
- Длительность "0" = 872 * 0.5 мкс = 436 мкс.
- Общий период = (Длительность "1" + Длительность "0") = 64 мкс + 436 мкс = 500 мкс.
- Частота сигнала = 1 / Общий период = 1 / (500 * 10^-6) = 2000 Гц = 2 кГц.

## Вывод

Теоретическая частота, рассчитанная по приведенным выше данным, составляет 2 кГц, что совпадает с частотой, зарегистрированной на осциллографе (2 кГц).

# Пункт 4

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 64
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x40) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 64
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x40) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

# Пункт 5

Чтобы увеличить период сигнала в 2 раза, нужно уменьшить частоту тактирования таймера в 2 раза. Это можно сделать, увеличив значение регистра предварительного делителя (`TIM1_PSCR`).

$$F_{TIM1} = \frac{F_{MCU}}{(PSCR + 1)}$$
где:
- $F_{MCU}$ — частота тактирования микроконтроллера (2 МГц по умолчанию).
- $PSCR$ — значение предварительного делителя.

Увеличим значение предварительного делителя с 0 до 1. Это уменьшит частоту таймера в 2 раза:
$$F_{TIM1} = \frac{2 \text{ МГц}}{(1 + 1)} = 1 \text{ МГц}$$

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Старший байт предварительного делителя
    TIM1_PSCRL = 0x01;  // Младший байт предварительного делителя (деление на 2)
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x80) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x80) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

## Ответ на вопрос

Длительность импульса увеличилась в 2 раза, так как частота таймера уменьшилась в 2 раза (за счет увеличения предварительного делителя). Это привело к увеличению времени счета таймера.

# Пункт 6

Чтобы уменьшить период сигнала в 2 раза, нужно уменьшить значение регистра автоперезагрузки (TIM1_ARR) в 2 раза. Это приведет к тому, что таймер будет считать до меньшего значения, и период сигнала уменьшится. Уменьшим значение регистра автоперезагрузки с 1000 до 500.

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x01;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xF4;   // Регистр автоперезагрузки (младший байт, 500 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x80) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x80) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

## Ответ на вопрос

Длительность импульса уменьшилась в 2 раза, так как значение регистра автоперезагрузки уменьшилось в 2 раза. Это привело к уменьшению времени счета таймера.

# Пункт 7

Для формирования импульсов длительностью 20 мс нужно настроить таймер так, чтобы он переполнялся каждые 20 мс и использовать флаг переполнения (`UIF`) для переключения состояния порта G.

### Расчет значения для регистра автоперезагрузки (`TIM1_ARR`)

- Частота тактирования таймера: 2 МГц (по умолчанию).
- Период одного такта таймера: 0,5 мкс
- Для формирования импульса длительностью 20 мс:
$$\text{Количество тактов} = \frac{20 \text{ мс}}{0.5 \text{ мкс}} = 40000$$
- Значение для регистра автоперезагрузки:
$$\text{TIM1\_ARR} = 40000 - 1 = 39999 \quad (\text{так как счет начинается с 0})$$
- В шестнадцатеричной системе: 
$$39999_{10} = \text{0x9C3F}$$

```C
#include <iostm8s207.h>

#define IS_TIMER_OVERFLOW() (TIM1_SR1 & (1 << 0))

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x9C;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0x3F;   // Регистр автоперезагрузки (младший байт) 39999 в десятичной системе
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем переполнения таймера (флаг UIF)
        if (IS_TIMER_OVERFLOW()) {
            TIM1_SR1 &= ~(1 << 0);
            PG_ODR ^= (1 << 0);
        }
    }
}
```

# Пункт 8

```C

```

# Пункт 9

```C

```

# Пункт 10

```C

```

# Пункт 11

```C

```

# Пункт 12

```C

```

# Пункт 13

```C

```

# Пункт 14

```C

```

# Пункт 16

```C

```

# Пункт 17

```C

```