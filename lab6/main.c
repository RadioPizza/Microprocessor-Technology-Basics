#include "main.h"

#define LED_PORT PG
#define LED_PIN 0

#define IS_TIMER_OVERFLOW() (TIM1_SR1 & (1 << 0))

#define PWM_PERIOD 200            // Период программного ШИМ
volatile uint8_t pwm_counter = 0; // Счётчик тактов ШИМ (0 .. PWM_PERIOD-1)
volatile uint8_t pwm_value = 0;   // Текущее значение скважности (0 .. PWM_PERIOD)
volatile int8_t direction = 1;    // Направление изменения: +1 - увеличение, -1 - уменьшение

/**
 * @brief Задержка в микросекундах с использованием таймера TIM1.
 *
 * @param us Количество микросекунд для задержки.
 * @note Эта функция имеет оверхед около 30 мкс.
 */
void delay_us(uint16_t us)
{
    --us;                  // Уменьшаем значение на 1 для корректной работы
    TIM1_CR1 |= 0x04;      // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00;     // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x01;     // Устанавливаем младший байт делителя
    TIM1_EGR |= 0x01;      // Генерация обновления
    TIM1_ARRH = us >> 8;   // Загружаем старший байт регистра автоперезагрузки
    TIM1_ARRL = us & 0xFF; // Загружаем младший байт регистра автоперезагрузки
    TIM1_CR1 &= ~0x04;     // Выключаем ARPE
    TIM1_CR1 |= 0x09;      // Включаем таймер в режиме one-pulse mode
    while (!IS_TIMER_OVERFLOW())
        // Ждем переполнения таймера
        ;
    TIM1_SR1 = 0x00; // Сбрасываем флаг обновления
}

/**
 * @brief Задержка в миллисекнудах с использованием таймера TIM1.
 *
 * @param ms Количество миллисекунд для задержки.
 */
void delay_ms(uint16_t ms)
{
    uint16_t i;
    for (i = 0; i < ms; i++)
    {
        delay_us(970); // 1000 мкс = 1 мс; учитываем оверхед 30 мкс
    }
}

/**
 * @brief Обработчик прерывания таймера TIM1 (переполнение).
 *
 * @note Эта функция вызывается при переполнении таймера TIM1.
 *       Инвертирует нулевой бит порта G и сбрасывает флаг переполнения.
 */
@far @interrupt void TIM1_IRQHandler(void)
{
    pwm_counter++; // Переход к следующему такту ШИМ
    if (pwm_counter >= PWM_PERIOD)
    {
        pwm_counter = 0;

        // Обновление значения скважности
        pwm_value += direction;
        if ((pwm_value == PWM_PERIOD) || (pwm_value == 0))
        {
            direction = -direction;
        }
    }

    // Генерация программного ШИМ на PG0
    if (pwm_counter < pwm_value)
    {
        PG_ODR = 0x01;
    }
    else
    {
        PG_ODR = 0x00;
    }
}

/**
 * @brief Инициализация таймера TIM1 для генерации прерываний с заданной частотой.
 *
 * @param period_us Период переполнения таймера в микросекундах.
 */
void tim1_init(uint32_t period_us)
{
    // Для 2 МГц тактирования, делитель 1, такт = 0,5 мкс
    // Для period_us микросекунд, нужно period_us / 0.5 = period_us * 2 такта.
    // Поэтому, устанавливаем ARR = period_us * 2 - 1.
    uint16_t arr_value = period_us * 2 - 1;

    TIM1_CR1 &= ~0x01; // Выключаем таймер, чтобы безопасно настроить его
    TIM1_CR1 |= 0x04;  // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00; // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x00; // Устанавливаем младший байт делителя (делитель 1)
    TIM1_ARRH = arr_value >> 8;
    TIM1_ARRL = arr_value & 0xFF;
    TIM1_EGR |= 0x01;     // Генерация обновления, чтобы применить новые значения ARR и PSC
    TIM1_IER |= (1 << 0); // Разрешаем прерывание по переполнению (UIE)
    TIM1_CR1 &= ~0x04;    // Выключаем ARPE после настройки
    TIM1_CR1 |= 0x01;     // Включаем таймер
}

/**
 * @brief Инициализация аппаратного ШИМ на канале 1 таймера TIM1.
 */
void tim1_init_pwm(void)
{
    // Регистр сравнения/захвата канала 1 (Channel 1 mode register)
    TIM1_CCMR1 = 0x68;  // Режим PWM1 (биты OC1M=110), предварительная загрузка включена (OC1PE=1)
    
    // Регистр управления каналом 1 (Capture/Compare enable register)
    TIM1_CCER1 = 0x01;  // Включение канала 1 (CC1E=1), активный уровень высокий (CC1P=0)
    
    // Регистр управления выходом (Break and dead-time register)
    TIM1_BKR = 0x80;    // Разрешение основного выхода (MOE=1)
    
    // Регистры предварительного делителя частоты (Prescaler)
    TIM1_PSCRH = 0x00;  // Старший байт делителя (PSCR = 19)
    TIM1_PSCRL = 0x13;  // Младший байт делителя 
    // Частота таймера = 2 МГц / (19 + 1) = 100 кГц (1 такт = 10 мкс)
    
    // Регистры автоперезагрузки (Auto-reload register)
    TIM1_ARRH = 0x07;   // Старший байт ARR (ARR = 1999)
    TIM1_ARRL = 0xCF;   // Младший байт ARR 
    // Период ШИМ = (ARR + 1) * 10 мкс = 20 мс
    
    // Регистры сравнения канала 1 (Capture/Compare register)
    TIM1_CCR1H = 0x00;  // Старший байт CCR1 (CCR1 = 100)
    TIM1_CCR1L = 0x64;  // Младший байт CCR1 
    // Длительность импульса = CCR1 * 10 мкс = 1 мс
}

void main(void)
{
    // Настройка вывода PC1 (TIM1_CH1)
    PC_DDR |= (1 << 1); // Направление: выход
    PC_CR1 |= (1 << 1); // Режим: push-pull
    PC_CR2 |= (1 << 1); // Скорость: 10 МГц

    // Инициализация ШИМ
    tim1_init_pwm();

    // Запуск таймера
    TIM1_CR1 |= (1 << 0); // Включение таймера (CEN=1)
}