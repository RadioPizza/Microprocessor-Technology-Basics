# Пункт 2

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x80) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x80) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

# Пункт 3

## Характеристики полученного сигнала

Частота реального сигнала - 2 кГц, длительность импульса 60-65 мкс.

## Расчёт теоретических значений

Таймер настроен на частоту 2 МГц (предварительный делитель 1). Регистр автоперезагрузки (ARR) настроен на 1000 (0x03E8).

$$T = \frac{1}{f} = \frac{1}{2 \cdot 10^6 \text{ Гц}} = 0.5 \text{ мкс}$$

Условие внутри бесконечного цикла задаёт 128 тактов для логической "1" и оставшиеся (1000 - 128) = 872 такта для логической "0".
   
- Длительность "1" = 128 * 0.5 мкс = 64 мкс.
- Длительность "0" = 872 * 0.5 мкс = 436 мкс.
- Общий период = (Длительность "1" + Длительность "0") = 64 мкс + 436 мкс = 500 мкс.
- Частота сигнала = 1 / Общий период = 1 / (500 * 10^-6) = 2000 Гц = 2 кГц.

## Вывод

Теоретическая частота, рассчитанная по приведенным выше данным, составляет 2 кГц, что совпадает с частотой, зарегистрированной на осциллографе (2 кГц).

# Пункт 4

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Предварительный делитель (деление на 1)
    TIM1_PSCRL = 0x00;  // Частота таймера = 2 МГц
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 64
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x40) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 64
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x40) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

# Пункт 5

Чтобы увеличить период сигнала в 2 раза, нужно уменьшить частоту тактирования таймера в 2 раза. Это можно сделать, увеличив значение регистра предварительного делителя (`TIM1_PSCR`).

$$F_{TIM1} = \frac{F_{MCU}}{(PSCR + 1)}$$
где:
- $F_{MCU}$ — частота тактирования микроконтроллера (2 МГц по умолчанию).
- $PSCR$ — значение предварительного делителя.

Увеличим значение предварительного делителя с 0 до 1. Это уменьшит частоту таймера в 2 раза:
$$F_{TIM1} = \frac{2 \text{ МГц}}{(1 + 1)} = 1 \text{ МГц}$$

```C
#include <iostm8s207.h>

void main(void) {
    // Настройка порта G
    PG_DDR |= (1 << 0);  // Настройка нулевой линии порта G как выход
    PG_CR1 |= (1 << 0);  // Двухтактный выход
    PG_CR2 |= (1 << 0);  // Частота 10 МГц

    // Настройка таймера TIM1
    TIM1_PSCRH = 0x00;  // Старший байт предварительного делителя
    TIM1_PSCRL = 0x01;  // Младший байт предварительного делителя (деление на 2)
    TIM1_ARRH = 0x03;   // Регистр автоперезагрузки (старший байт)
    TIM1_ARRL = 0xE8;   // Регистр автоперезагрузки (младший байт, 1000 в десятичной системе)
    TIM1_CR1 |= (1 << 0);  // Включаем таймер

    while (1) {
        // Ждем, пока счетчик таймера не достигнет 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) <= 0x80) {
            PG_ODR |= (1 << 0);  // Устанавливаем логическую «1» на порт G
        }
        // Ждем, пока счетчик таймера не станет больше 128
        while ((TIM1_CNTRH << 8 | TIM1_CNTRL) > 0x80) {
            PG_ODR &= ~(1 << 0);  // Устанавливаем логический «0» на порт G
        }
    }
}
```

## Ответ на вопрос

Длительность импульса увеличилась в 2 раза, так как частота таймера уменьшилась в 2 раза (за счет увеличения предварительного делителя). Это привело к увеличению времени счета таймера.

# Пункт 6

```C

```

# Пункт 7

```C

```

# Пункт 8

```C

```

# Пункт 9

```C

```

# Пункт 10

```C

```

# Пункт 11

```C

```

# Пункт 12

```C

```

# Пункт 13

```C

```

# Пункт 14

```C

```

# Пункт 16

```C

```

# Пункт 17

```C

```