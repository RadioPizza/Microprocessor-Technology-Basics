#include "main.h"

#define IS_TIMER_OVERFLOW() (TIM1_SR1 & (1 << 0))

/**
 * @brief Задержка в микросекундах с использованием таймера TIM1.
 *
 * @param us Количество микросекунд для задержки.
 * @note Эта функция имеет оверхед около 30 мкс.
 */
void delay_us(uint16_t us)
{
    --us;                  // Уменьшаем значение на 1 для корректной работы
    TIM1_CR1 |= 0x04;      // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00;     // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x01;     // Устанавливаем младший байт делителя
    TIM1_EGR |= 0x01;      // Генерация обновления
    TIM1_ARRH = us >> 8;   // Загружаем старший байт регистра автоперезагрузки
    TIM1_ARRL = us & 0xFF; // Загружаем младший байт регистра автоперезагрузки
    TIM1_CR1 &= ~0x04;     // Выключаем ARPE
    TIM1_CR1 |= 0x09;      // Включаем таймер в режиме one-pulse mode
    while (!IS_TIMER_OVERFLOW())
        // Ждем переполнения таймера
        ;
    TIM1_SR1 = 0x00;    // Сбрасываем флаг обновления
}

/**
 * @brief Задержка в миллисекнудах с использованием таймера TIM1.
 *
 * @param ms Количество миллисекунд для задержки.
 */
void delay_ms(uint16_t ms)
{
    uint16_t i;
    for (i = 0; i < ms; i++)
    {
        delay_us(970);  // 1000 мкс = 1 мс; учитываем оверхед 30 мкс
    }
}

/**
 * @brief Обработчик прерывания таймера TIM1 (переполнение).
 *
 * @note Эта функция вызывается при переполнении таймера TIM1.
 *       Инвертирует нулевой бит порта G и сбрасывает флаг переполнения.
 */
@far @interrupt void TIM1_IRQHandler(void)
{
    // Инверсия состояния: если бит 0 установлен, сбрасываем его, иначе – устанавливаем.
    PG_ODR ^= (1 << 0);     // Инверсия нулевого пина порта G

    TIM1_SR1 &= ~(1 << 0);  // Очистка флага переполнения (UIF)
}

/**
 * @brief Инициализация таймера TIM1 для генерации прерываний с заданной частотой.
 *
 * @param period_us Период переполнения таймера в микросекундах.
 */
void tim1_init(uint16_t period_us)
{
    // Для 2 МГц тактирования, делитель 1, такт = 0,5 мкс
    // Для period_us микросекунд, нужно period_us / 0.5 = period_us * 2 такта.
    // Поэтому, устанавливаем ARR = period_us * 2 - 1.
    uint16_t arr_value = period_us * 2 - 1;

    TIM1_CR1 &= ~0x01;  // Выключаем таймер, чтобы безопасно настроить его
    TIM1_CR1 |= 0x04;   // Активируем предварительную загрузку (ARPE)
    TIM1_PSCRH = 0x00;  // Устанавливаем старший байт делителя
    TIM1_PSCRL = 0x00;  // Устанавливаем младший байт делителя (делитель 1)
    TIM1_ARRH = arr_value >> 8;
    TIM1_ARRL = arr_value & 0xFF;
    TIM1_EGR |= 0x01;       // Генерация обновления, чтобы применить новые значения ARR и PSC
    TIM1_IER |= (1 << 0);   // Разрешаем прерывание по переполнению (UIE)
    TIM1_CR1 &= ~0x04;      // Выключаем ARPE после настройки
    TIM1_CR1 |= 0x01;       // Включаем таймер
}

void main(void)
{
    // Настройка порта G: настраиваем вывод PG0 для индикации работы таймера.
    PG_DDR |= (1 << 0);  // PG0 - выход
    PG_CR1 |= (1 << 0);  // PG0 - двухтактный режим (push-pull)
    PG_CR2 |= (1 << 0);  // PG0 - максимальная скорость (10 МГц)

    // Инициализируем таймер TIM1 для генерации прерываний каждые 5 мс.
    tim1_init(5000);
    // Разрешаем глобальные прерывания (Run Interrupt Mode).
    _asm("rim");
}